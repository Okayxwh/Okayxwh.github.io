<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis入门篇</title>
    <link href="/2022/06/08/article-redis/"/>
    <url>/2022/06/08/article-redis/</url>
    
    <content type="html"><![CDATA[<h1 id="一-初识Redis"><a href="#一-初识Redis" class="headerlink" title="一.初识Redis"></a>一.初识Redis</h1><h2 id="1-认识Nosql"><a href="#1-认识Nosql" class="headerlink" title="1.认识Nosql"></a>1.认识Nosql</h2><p>1.SQL是关系型数据库，NoSQL是非关系型数据库</p><p><img src="/2022/06/08/article-redis/image-20220608205932339.png" alt="image-20220608205932339"></p><h2 id="2-认识Redis"><a href="#2-认识Redis" class="headerlink" title="2.认识Redis"></a>2.认识Redis</h2><p>1.Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库</p><p>2.<strong>特征：</strong></p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="3-安装Redis"><a href="#3-安装Redis" class="headerlink" title="3.安装Redis"></a>3.安装Redis</h2><p><img src="/2022/06/08/article-redis/image-20220608210804294.png" alt="image-20220608210804294"></p><h3 id="3-1-安装Redis依赖"><a href="#3-1-安装Redis依赖" class="headerlink" title="3.1.安装Redis依赖"></a>3.1.安装Redis依赖</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><h3 id="3-2-上传安装包并解压"><a href="#3-2-上传安装包并解压" class="headerlink" title="3.2.上传安装包并解压"></a>3.2.上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="/2022/06/08/article-redis/image-20211211071712536.png" alt="image-20211211071712536"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p><img src="/2022/06/08/article-redis/image-20211211080151539.png" alt="image-20211211080151539"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-6.2.6.tar.gz<br></code></pre></td></tr></table></figure><p>解压后：</p><p><img src="/2022/06/08/article-redis/image-20211211080339076.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="/2022/06/08/article-redis/image-20211211080603710.png" alt="image-20211211080603710"></p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3.启动"></a>3.3.启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="3-3-1-默认启动"><a href="#3-3-1-默认启动" class="headerlink" title="3.3.1.默认启动"></a>3.3.1.默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/06/08/article-redis/image-20211211081716167.png" alt="image-20211211081716167"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h4 id="3-3-2-指定配置启动"><a href="#3-3-2-指定配置启动" class="headerlink" title="3.3.2.指定配置启动"></a>3.3.2.指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="/2022/06/08/article-redis/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> redis.<span class="hljs-keyword">conf</span> redis.<span class="hljs-keyword">conf</span>.bck<br></code></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h4 id="3-3-3-开机自启"><a href="#3-3-3-开机自启" class="headerlink" title="3.3.3.开机自启"></a>3.3.3.开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></table></figure><h3 id="3-4-Redis客户端"><a href="#3-4-Redis客户端" class="headerlink" title="3.4.Redis客户端"></a>3.4.Redis客户端</h3><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h4 id="3-4-1-Redis命令行客户端"><a href="#3-4-1-Redis命令行客户端" class="headerlink" title="3.4.1 Redis命令行客户端"></a>3.4.1 Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="/2022/06/08/article-redis/image-20220609211954479.png" alt="image-20220609211954479"></p><h4 id="3-4-2-图形化桌面客户端"><a href="#3-4-2-图形化桌面客户端" class="headerlink" title="3.4.2 图形化桌面客户端"></a>3.4.2 图形化桌面客户端</h4><p><strong>（1）安装链接</strong>：<a href="https://pan.baidu.com/s/1n_aLo3LskSYvQ_2gWIMxnw">https://pan.baidu.com/s/1n_aLo3LskSYvQ_2gWIMxnw</a><br>提取码：hk7m </p><p><strong>（2） 建立连接</strong></p><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="/2022/06/08/article-redis/image-20211214155424842.png" alt="image-20211214155424842"></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="/2022/06/08/article-redis/image-20211211111614483.png"></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="/2022/06/08/article-redis/image-20211214155804523.png" alt="image-20211214155804523"></p><p>点击即可建立连接了：</p><p><strong>注：如果连接不上要关闭linux的防火墙systemctl stop firewalld.service</strong></p><p><img src="/2022/06/08/article-redis/image-20211214155849495.png" alt="image-20211214155849495"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择 0号库</span><br>select 0<br></code></pre></td></tr></table></figure><h1 id="二、Redis常见命令"><a href="#二、Redis常见命令" class="headerlink" title="二、Redis常见命令"></a>二、Redis常见命令</h1><h2 id="1-Redis数据结构介绍"><a href="#1-Redis数据结构介绍" class="headerlink" title="1. Redis数据结构介绍"></a>1. Redis数据结构介绍</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>1.Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样。</p><p><strong>redis的数据结构是针对value的</strong></p><p><img src="/2022/06/08/article-redis/image-20220609213819112.png" alt="image-20220609213819112"></p><h3 id="1-2-命令使用方法帮助"><a href="#1-2-命令使用方法帮助" class="headerlink" title="1.2 命令使用方法帮助"></a>1.2 命令使用方法帮助</h3><p>1.Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令,也可以通过终端查找命令的使用。</p><p>例如<strong>想知道例如想知道keys命令怎么用可以在终端打出help keys</strong></p><p><img src="/2022/06/08/article-redis/image-20220609214406943.png" alt="image-20220609214406943"></p><h2 id="2-Redis通用命令"><a href="#2-Redis通用命令" class="headerlink" title="2. Redis通用命令"></a>2. Redis通用命令</h2><p>1.通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">keys</td><td align="left">查看符合模板的所有key</td></tr><tr><td align="left">del</td><td align="left">删除一个指定的key</td></tr><tr><td align="left">exists</td><td align="left">判断key是否存在</td></tr><tr><td align="left">expire</td><td align="left">给一个key设置有效期，有效期到期时该key会被自动删除</td></tr><tr><td align="left">ttl</td><td align="left">查看一个KEY的剩余有效期</td></tr></tbody></table><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="/2022/06/08/article-redis/image-20220609215413412.png" alt="image-20220609215413412"></p><h2 id="3-不同数据结构的操作命令"><a href="#3-不同数据结构的操作命令" class="headerlink" title="3. 不同数据结构的操作命令"></a>3. 不同数据结构的操作命令</h2><h3 id="3-1-String类型的常见命令"><a href="#3-1-String类型的常见命令" class="headerlink" title="3.1 String类型的常见命令"></a>3.1 String类型的常见命令</h3><h4 id="3-1-1介绍"><a href="#3-1-1介绍" class="headerlink" title="3.1.1介绍"></a>3.1.1介绍</h4><p>（1）String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过<strong>根据字符串的格式不同，又可以分为3类：</strong></p><p><strong>string</strong>：普通字符串</p><p><strong>int</strong>：整数类型，可以做自增、自减操作</p><p><strong>float</strong>：浮点类型，可以做自增、自减操作</p><p>（2）不管是哪种格式，<strong>底层都是字节数组形式存储</strong>，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><h4 id="3-1-2命令"><a href="#3-1-2命令" class="headerlink" title="3.1.2命令"></a>3.1.2命令</h4><table><thead><tr><th>String的常见命令有</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>set</td><td>添加或者修改已经存在的一个String类型的键值对</td><td>set name jack</td></tr><tr><td>get</td><td>根据key获取String类型的value</td><td>get name</td></tr><tr><td>mset</td><td>批量添加多个String类型的键值对</td><td>mset name jack age 19</td></tr><tr><td>mget</td><td>根据多个key获取多个String类型的value</td><td>mget name age</td></tr><tr><td>incr</td><td>让一个整型的key自增1</td><td>incr age</td></tr><tr><td>incrby</td><td>让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td><td>incr age 3</td></tr><tr><td>incrbyfloat</td><td>让一个浮点类型的数字自增并指定步长</td><td>incrbyfloat num 2.1</td></tr><tr><td>setnx</td><td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td><td>setnx name jack</td></tr><tr><td>setex</td><td>添加一个String类型的键值对，并且指定有效期</td><td>setex name 20 jack</td></tr></tbody></table><p><img src="/2022/06/08/article-redis/image-20220610094310575.png" alt="image-20220610094310575"></p><p>setnx name jack命令其实和set name jack nx这个命令效果类似，nx是set命令选项（如图）</p><p>setex name 10 jack 命令其实和set name jack ex 10命令效果类似，ex是set命令选项</p><h4 id="3-1-3Redis的key的格式，-项目名-业务名-类型-id"><a href="#3-1-3Redis的key的格式，-项目名-业务名-类型-id" class="headerlink" title="3.1.3Redis的key的格式，[项目名]:[业务名]:[类型]:[id]"></a>3.1.3Redis的key的格式，[项目名]:[业务名]:[类型]:[id]</h4><p>（1）原因：Redis没有类似MySQL中的Table的概念，我们该<strong>如何区分不同类型的key</strong>呢？例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1。</p><p>（2）解决：Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="/2022/06/08/article-redis/image-20220610103520524.png" alt="image-20220610103520524"></p><p>（3）例子</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><p>uuser相关的key：heima:user:1</p><p>uproduct相关的key：heima:product:1</p><h3 id="3-2Hash类型的常见命令"><a href="#3-2Hash类型的常见命令" class="headerlink" title="3.2Hash类型的常见命令"></a>3.2Hash类型的常见命令</h3><h4 id="3-2-1介绍"><a href="#3-2-1介绍" class="headerlink" title="3.2.1介绍"></a>3.2.1介绍</h4><p>（1）Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>原因：String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很<strong>不方便</strong>（如图）</p><p><img src="/2022/06/08/article-redis/image-20220610110946312.png" alt="image-20220610110946312"></p><p>解决：Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD（如图）</p><p><img src="/2022/06/08/article-redis/image-20220610111047559.png" alt="image-20220610111047559"></p><h4 id="3-2-2Hash类型的常见命令"><a href="#3-2-2Hash类型的常见命令" class="headerlink" title="3.2.2Hash类型的常见命令"></a>3.2.2Hash类型的常见命令</h4><table><thead><tr><th>Hash的常见命令有：</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改hash类型key的field的值</td><td>hset  heima:user:3  name  jack</td></tr><tr><td>HGET key field</td><td>获取一个hash类型key的field的值</td><td>hget heima:user:3 name</td></tr><tr><td>HMSET</td><td>批量添加多个hash类型key的field的值</td><td>hmset heima:user:3 name jack age 18</td></tr><tr><td>HMGET</td><td>批量获取多个hash类型key的field的值</td><td>hmget heima:user:3 name age</td></tr><tr><td>HGETALL</td><td>获取一个hash类型的key中的所有的field和value</td><td>hgetall heima:user:3</td></tr><tr><td>HKEYS</td><td>获取一个hash类型的key中的所有的field</td><td>hkeys heima:user:3</td></tr><tr><td>HVALS</td><td>获取一个hash类型的key中的所有的value</td><td>hvals heima:user:3</td></tr><tr><td>HINCRBY</td><td>让一个hash类型key的字段值自增并指定步长</td><td>hincrby heima:user:3 age 5</td></tr><tr><td>HSETNX</td><td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td><td>hsetnx heima:user:3 sex man</td></tr></tbody></table><h3 id="3-3List类型的常用命令"><a href="#3-3List类型的常用命令" class="headerlink" title="3.3List类型的常用命令"></a>3.3List类型的常用命令</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1.介绍"></a>3.3.1.介绍</h4><p>(1)Redis中的List类型与Java中的LinkedList类似，可以看做是一个<strong>双向链表结构</strong>。既可以支持正向检索和也可以支持反向检索。(<strong>左右两边都可进行插入弹出</strong>)</p><p>(2)特征也与LinkedList类似：</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除快</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><h4 id="3-3-2-List类型的常用命令"><a href="#3-3-2-List类型的常用命令" class="headerlink" title="3.3.2 List类型的常用命令"></a>3.3.2 List类型的常用命令</h4><table><thead><tr><th>命令</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>LPUSH key element …</td><td>向列表左侧插入一个或多个元素</td><td>lpush users 1 2 3</td></tr><tr><td>RPUSH key element …</td><td>向列表右侧插入一个或多个元素</td><td>rpush users 3 4 5</td></tr><tr><td>LPOP key [count]</td><td>移除并返回列表左侧的第一个元素，没有则返回nil  ,count不写就移除一个，写了就移除count个</td><td>lpop users</td></tr><tr><td>RPOP key [count]</td><td>移除并返回列表右侧的第一个元素，count不写就移除一个，写了就移除count个</td><td>rpop users</td></tr><tr><td>LRANGE key star end</td><td>RPOP key [count]返回一段角标（下标）范围内的所有元素</td><td>lrange users 0 2</td></tr><tr><td>BLPOP和BRPOP</td><td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil,例如blpop users 200，<strong>200是指list中没有元素的时候不是直接返回nil,而是等待200秒，如果200秒内插入值就返回，200秒内没有插入值就返回nil</strong></td><td>blpop users 200</td></tr></tbody></table><h4 id="3-3-4思考"><a href="#3-3-4思考" class="headerlink" title="3.3.4思考"></a>3.3.4思考</h4><p>1、如何利用List结构模拟一个栈?（清新脱俗的例子，喝酒喝吐了就是栈，先进后出）</p><ul><li>入口和出口在同一边（例如都用lpush和lpop）</li></ul><p>2、如何利用List结构模拟一个队列?（喝酒喝了没吐去上厕所就是队列,先进先出）</p><ul><li>入口和出口在不同边(例如都用lpush和rpop)</li></ul><p>3、如何利用List结构模拟一个阻塞队列?</p><ul><li><p>入口和出口在不同边(例如都用lpush和rpop)</p></li><li><p>出队时采用BLPOP或BRPOP</p></li></ul><h3 id="3-4Set类型的常用命令"><a href="#3-4Set类型的常用命令" class="headerlink" title="3.4Set类型的常用命令"></a>3.4Set类型的常用命令</h3><h4 id="3-4-1-介绍"><a href="#3-4-1-介绍" class="headerlink" title="3.4.1 介绍"></a>3.4.1 介绍</h4><p>(1)Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="3-4-2-Set类型常用命令"><a href="#3-4-2-Set类型常用命令" class="headerlink" title="3.4.2 Set类型常用命令"></a>3.4.2 Set类型常用命令</h4><p>单个集合的操作</p><table><thead><tr><th>命令</th><th>介绍</th><th>例子</th></tr></thead><tbody><tr><td>SADD key member …</td><td>向set中添加一个或多个元素</td><td>sadd s1 a b c</td></tr><tr><td>SREM key member …</td><td>移除set中的指定元素</td><td>srem s1 a b c</td></tr><tr><td>SCARD key</td><td>返回set中元素的个数</td><td>scard s1</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于set中</td><td>sismember s1 a</td></tr><tr><td>SMEMBERS</td><td>获取set中的所有元素</td><td>smembers s1</td></tr></tbody></table><p>多个集合的操作</p><table><thead><tr><th>命令</th><th>介绍</th><th>例子</th></tr></thead><tbody><tr><td>SINTER key1 key2 …</td><td>求key1与key2的交集</td><td>sinter s1 s2</td></tr><tr><td>SDIFF key1 key2 …</td><td>求key1与key2的差集,例如sdiff s1 s2，就是查找s1有但s2没有的元素</td><td>sdiff s1 s2</td></tr><tr><td>SUNION key1 key2 …</td><td>求key1和key2的并集</td><td>sunion s1 s2</td></tr></tbody></table><p>练习</p><p><img src="/2022/06/08/article-redis/image-20220613204043562.png" alt="image-20220613204043562"></p><h3 id="3-5-SortedSet类型的常用命令"><a href="#3-5-SortedSet类型的常用命令" class="headerlink" title="3.5 SortedSet类型的常用命令"></a>3.5 SortedSet类型的常用命令</h3><h4 id="3-5-1介绍"><a href="#3-5-1介绍" class="headerlink" title="3.5.1介绍"></a>3.5.1介绍</h4><p>(1)Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><h4 id="3-5-2-SortedSet类型的常用命令"><a href="#3-5-2-SortedSet类型的常用命令" class="headerlink" title="3.5.2 SortedSet类型的常用命令"></a>3.5.2 SortedSet类型的常用命令</h4><p>（1）命令</p><table><thead><tr><th align="left">命令</th><th>介绍</th></tr></thead><tbody><tr><td align="left">ZADD key score member</td><td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td align="left">ZREM key member</td><td>删除sorted set中的一个指定元素</td></tr><tr><td align="left">ZSCORE key member</td><td>获取sorted set中的指定元素的score值</td></tr><tr><td align="left">ZRANK key member</td><td>获取sorted set 中的指定元素的排名</td></tr><tr><td align="left">ZCARD key</td><td>获取sorted set中的元素个数</td></tr><tr><td align="left">ZCOUNT key min max</td><td>统计score值在给定范围内的所有元素的个数</td></tr><tr><td align="left">ZINCRBY key increment member</td><td>让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td align="left">ZRANGE key min max</td><td>按照score排序后，获取指定排名范围内的元素</td></tr><tr><td align="left">ZRANGEBYSCORE key min max</td><td>按照score排序后，获取指定score范围内的元素</td></tr><tr><td align="left">ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p>注：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如ZRANK key member就是升序的排序，ZREVRANK key member就是降序的排序</p><p>（2）练习</p><p><img src="/2022/06/08/article-redis/image-20220614185333596.png" alt="image-20220614185333596"></p><h1 id="三、Redis的Java客户端"><a href="#三、Redis的Java客户端" class="headerlink" title="三、Redis的Java客户端"></a>三、Redis的Java客户端</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>（1）在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><p><img src="/2022/06/08/article-redis/image-20220614192631723.png" alt="image-20220614192631723"></p><p>（2）redis的java客户端如下图</p><p><img src="/2022/06/08/article-redis/image-20220614192718606.png" alt="image-20220614192718606"></p><h2 id="2-Jedis客户端"><a href="#2-Jedis客户端" class="headerlink" title="2.Jedis客户端"></a>2.Jedis客户端</h2><h3 id="2-1-jedis"><a href="#2-1-jedis" class="headerlink" title="2.1.jedis"></a>2.1.jedis</h3><p>（1）Jedis的官网地址： <a href="https://github.com/redis/jedis%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A">https://github.com/redis/jedis，我们先来个快速入门：</a></p><p>（2）开发步骤</p><p>1.建立一个maven工程，引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">      <br>&lt;!--jedis依赖--&gt;<br>&lt;dependency&gt;<br>          &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>          &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>          &lt;version&gt;<span class="hljs-number">3.7</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>      &lt;/dependency&gt;<br>          <br>&lt;!--要测试所以引入单元测试依赖--&gt;<br>      &lt;dependency&gt;<br>          &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>          &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;<br>          &lt;version&gt;<span class="hljs-number">5.8</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>          &lt;scope&gt;test&lt;/scope&gt;<br>      &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2.建立连接,测试，关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 许伟浩</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-comment">//@BeforeEach表示在所有测试方法执行之前执行该方法</span><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//建立连接</span><br>        jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//设置密码</span><br>        jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">//选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//表示在所有测试方法执行之后执行该方法，关闭连接</span><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(jedis!=<span class="hljs-literal">null</span>)&#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//测试String类型</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小黑&quot;</span>);<br>        System.out.println(s1);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>        System.out.println(s2);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br><br>    <span class="hljs-comment">//测试Hash类型</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span>&#123;<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;agr&quot;</span>,<span class="hljs-string">&quot;19&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hget</span> <span class="hljs-operator">=</span> jedis.hget(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(hget);<br>        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user&quot;</span>);<br>        System.out.println(map);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2022/06/08/article-redis/image-20220616194446218.png" alt="image-20220616194446218"></p><h3 id="2-2Jedis连接池"><a href="#2-2Jedis连接池" class="headerlink" title="2.2Jedis连接池"></a>2.2Jedis连接池</h3><p>（1）原因:Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><p>（2）步骤，创建配置类JedisConnectionFactory，进行配置，然后jedis &#x3D; JedisConnectionFactory.getJedis();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<br><span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 许伟浩</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">//最大连接数量</span><br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        <span class="hljs-comment">//最大空闲连接数量（没有人连的时候，最多备用的数量）</span><br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        <span class="hljs-comment">//最小空闲连接数量（没有人连的时候，最少备用的数量）</span><br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//没有连接可连的时候最长等多久</span><br>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">//创建连接池对象</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig,<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<br>                <span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> com.itheima.jedis.util.JedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 许伟浩</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-comment">//@BeforeEach表示在所有测试方法执行之前执行该方法</span><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//建立连接</span><br>        jedis = JedisConnectionFactory.getJedis();<br>        <span class="hljs-comment">//选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//表示在所有测试方法执行之后执行该方法</span><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(jedis!=<span class="hljs-literal">null</span>)&#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;小黑&quot;</span>);<br>        System.out.println(s1);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>        System.out.println(s2);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注：如果测试报错可能是linux防火墙的问题</strong></p><h2 id="3-SpringDataRedis"><a href="#3-SpringDataRedis" class="headerlink" title="3.SpringDataRedis"></a>3.SpringDataRedis</h2><h3 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h3><p>1.SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><p>提供了对不同Redis客户端的整合（Lettuce和Jedis）</p></li><li><p><strong>提供了RedisTemplate统一API来操作Redis</strong></p></li><li><p>支持Redis的发布订阅模型</p></li><li><p>支持Redis哨兵和Redis集群</p></li><li><p>支持基于Lettuce的响应式编程</p></li><li><p>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p></li><li><p>支持基于Redis的JDKCollection实现</p></li></ul><p>2.SpringDataRedis中提供了<strong>RedisTemplate</strong>工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/2022/06/08/article-redis/image-20220616212314526.png" alt="image-20220616212314526"></p><h3 id="3-2快速入门"><a href="#3-2快速入门" class="headerlink" title="3.2快速入门"></a>3.2快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><p>1.引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br>    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2.配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>  redis:<br>    host: <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.130</span><br>    port: <span class="hljs-number">6379</span><br>    password: <span class="hljs-number">123321</span><br>    lettuce:<br>      pool:<br>        max-active: <span class="hljs-number">8</span><br>        max-idle: <span class="hljs-number">8</span><br>        min-idle: <span class="hljs-number">0</span><br>        max-wait: 100ms<br></code></pre></td></tr></table></figure><p>3.注入RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br></code></pre></td></tr></table></figure><p>4.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;隔壁老王&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：SpringDataRedis的使用步骤：</p><p>1.引入spring-boot-starter-data-redis依赖</p><p>2.在application.yml配置Redis信息</p><p>3.注入RedisTemplate</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA集合学习之Map篇</title>
    <link href="/2022/06/07/article_map/"/>
    <url>/2022/06/07/article_map/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合学习之Map篇"><a href="#JAVA集合学习之Map篇" class="headerlink" title="JAVA集合学习之Map篇"></a>JAVA集合学习之Map篇</h1><h2 id="1-Map-接口和常用方法"><a href="#1-Map-接口和常用方法" class="headerlink" title="1.Map 接口和常用方法"></a>1.Map 接口和常用方法</h2><h3 id="1-1Map-接口实现类的特点"><a href="#1-1Map-接口实现类的特点" class="headerlink" title="1.1Map 接口实现类的特点"></a>1.1Map 接口实现类的特点</h3><p><img src="/2022/06/07/article_map/image-20220607164146160.png" alt="image-20220607164146160"></p><p>1.Map用于保存具有映射关系的数据：Key-Value</p><p>2.Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p><p>3.Map中的key不允许重复，原因和HashSet一样，Set篇文章分析过源码</p><p>4.Map中的value可以重复</p><p>5.Map的key可以为null,value也可以为null,注意key为null,只能为一个，value为null,可以多个</p><p>6.常用String类作为Map的key</p><p>7.key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.map_;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Map_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//老韩解读Map 接口实现类的特点, 使用实现类HashMap</span><br>        <span class="hljs-comment">//1. Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value(双列元素)</span><br>        <span class="hljs-comment">//2. Map 中的 key 和  value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中</span><br>        <span class="hljs-comment">//3. Map 中的 key 不允许重复，原因和HashSet 一样，前面分析过源码.</span><br>        <span class="hljs-comment">//4. Map 中的 value 可以重复</span><br>        <span class="hljs-comment">//5. Map 的key 可以为 null, value 也可以为null ，注意 key 为null,</span><br>        <span class="hljs-comment">//   只能有一个，value 为null ,可以多个</span><br>        <span class="hljs-comment">//6. 常用String类作为Map的 key</span><br>        <span class="hljs-comment">//7. key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;韩顺平&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-string">&quot;no2&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>);<span class="hljs-comment">//当有相同的k , 就等价于替换.</span><br>        map.put(<span class="hljs-string">&quot;no3&quot;</span>, <span class="hljs-string">&quot;张三丰&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//等价替换</span><br>        map.put(<span class="hljs-string">&quot;no4&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-string">&quot;no5&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;赵敏&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(), <span class="hljs-string">&quot;金毛狮王&quot;</span>);<span class="hljs-comment">//k-v</span><br>        <span class="hljs-comment">// 通过get 方法，传入 key ,会返回对应的value</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;no2&quot;</span>));<span class="hljs-comment">//张无忌</span><br><br>        System.out.println(<span class="hljs-string">&quot;map=&quot;</span> + map);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>8.Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry(如图)</p><p><img src="/2022/06/07/article_map/image-20220607163543659.png" alt="image-20220607163543659"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.map_;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSource_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;韩顺平&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-string">&quot;no2&quot;</span>, <span class="hljs-string">&quot;张无忌&quot;</span>);<span class="hljs-comment">//k-v</span><br>        map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<span class="hljs-comment">//k-v</span><br><br>        <span class="hljs-comment">//老韩解读</span><br>        <span class="hljs-comment">//1. k-v 最后是 HashMap$Node node = newNode(hash, key, value, null)</span><br>        <span class="hljs-comment">//2. k-v 为了方便程序员的遍历，还会 创建 EntrySet 集合 ，该集合存放的元素的类型 Entry, 而一个Entry</span><br>        <span class="hljs-comment">//   对象就有k,v EntrySet&lt;Entry&lt;K,V&gt;&gt; 即： transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br>        <span class="hljs-comment">//3. entrySet 中， 定义的类型是 Map.Entry ，但是实际上存放的还是 HashMap$Node</span><br>        <span class="hljs-comment">//   这时因为 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span><br>        <span class="hljs-comment">//4. 当把 HashMap$Node 对象 存放到 entrySet 就方便我们的遍历, 因为 Map.Entry 提供了重要方法</span><br>        <span class="hljs-comment">//   K getKey(); V getValue();</span><br><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> map.entrySet();<br>        System.out.println(set.getClass());<span class="hljs-comment">// HashMap$EntrySet</span><br>        <span class="hljs-keyword">for</span> (Object obj : set) &#123;<br><br>            <span class="hljs-comment">//System.out.println(obj.getClass()); //HashMap$Node</span><br>            <span class="hljs-comment">//为了从 HashMap$Node 取出k-v</span><br>            <span class="hljs-comment">//1. 先做一个向下转型</span><br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) obj;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;-&quot;</span> + entry.getValue() );<br>        &#125;<br><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> map.keySet();<br>        System.out.println(set1.getClass());<br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br>        System.out.println(values.getClass());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-2Map-接口常用方法"><a href="#1-2Map-接口常用方法" class="headerlink" title="1.2Map 接口常用方法"></a>1.2Map 接口常用方法</h3><p>remove:根据键删除映射关系<br>get：根据键获取值<br>size:获取元素个数<br>isEmpty:判断个数是否为0<br>clear:清除k-v<br>containsKey:查找键是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.map_;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//演示map接口常用方法</span><br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">100</span>));<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<span class="hljs-comment">//替换-&gt; 一会分析源码</span><br>        map.put(<span class="hljs-string">&quot;王宝强&quot;</span>, <span class="hljs-string">&quot;马蓉&quot;</span>);<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-string">&quot;宋喆&quot;</span>, <span class="hljs-string">&quot;马蓉&quot;</span>);<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-string">&quot;刘令博&quot;</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;刘亦菲&quot;</span>);<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-string">&quot;鹿晗&quot;</span>, <span class="hljs-string">&quot;关晓彤&quot;</span>);<span class="hljs-comment">//OK</span><br>        map.put(<span class="hljs-string">&quot;hsp&quot;</span>, <span class="hljs-string">&quot;hsp的老婆&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;map=&quot;</span> + map);<br><br><span class="hljs-comment">//        remove:根据键删除映射关系</span><br>        map.remove(<span class="hljs-literal">null</span>);<br>        System.out.println(<span class="hljs-string">&quot;map=&quot;</span> + map);<br><span class="hljs-comment">//        get：根据键获取值</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;鹿晗&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;val=&quot;</span> + val);<br><span class="hljs-comment">//        size:获取元素个数</span><br>        System.out.println(<span class="hljs-string">&quot;k-v=&quot;</span> + map.size());<br><span class="hljs-comment">//        isEmpty:判断个数是否为0</span><br>        System.out.println(map.isEmpty());<span class="hljs-comment">//F</span><br><span class="hljs-comment">//        clear:清除k-v</span><br>        <span class="hljs-comment">//map.clear();</span><br>        System.out.println(<span class="hljs-string">&quot;map=&quot;</span> + map);<br><span class="hljs-comment">//        containsKey:查找键是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;结果=&quot;</span> + map.containsKey(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//T</span><br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-Map接口的遍历方式"><a href="#2-Map接口的遍历方式" class="headerlink" title="2.Map接口的遍历方式"></a>2.Map接口的遍历方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">//取出 所有的Key , 通过Key 取出对应的Value,keyset里面存的是map的所有key</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">keyset</span> <span class="hljs-operator">=</span> map.keySet();<br><span class="hljs-comment">//把所有的values取出,values里面存的是map的所有value</span><br><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br><span class="hljs-comment">//通过EntrySet 来获取 k-v</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">entrySet</span> <span class="hljs-operator">=</span> map.entrySet();<span class="hljs-comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.map_;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapFor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;王宝强&quot;</span>, <span class="hljs-string">&quot;马蓉&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;宋喆&quot;</span>, <span class="hljs-string">&quot;马蓉&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;刘令博&quot;</span>, <span class="hljs-literal">null</span>);<br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;刘亦菲&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;鹿晗&quot;</span>, <span class="hljs-string">&quot;关晓彤&quot;</span>);<br><br>        <span class="hljs-comment">//第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">keyset</span> <span class="hljs-operator">=</span> map.keySet();<br>        <span class="hljs-comment">//(1) 增强for</span><br>        System.out.println(<span class="hljs-string">&quot;-----第一种方式-------&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object key : keyset) &#123;<br>            System.out.println(key + <span class="hljs-string">&quot;-&quot;</span> + map.get(key));<br>        &#125;<br>        <span class="hljs-comment">//(2) 迭代器</span><br>        System.out.println(<span class="hljs-string">&quot;----第二种方式--------&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> keyset.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span>  iterator.next();<br>            System.out.println(key + <span class="hljs-string">&quot;-&quot;</span> + map.get(key));<br>        &#125;<br><br>        <span class="hljs-comment">//第二组: 把所有的values取出</span><br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br>        <span class="hljs-comment">//这里可以使用所有的Collections使用的遍历方法</span><br>        <span class="hljs-comment">//(1) 增强for</span><br>        System.out.println(<span class="hljs-string">&quot;---取出所有的value 增强for----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object value : values) &#123;<br>            System.out.println(value);<br>        &#125;<br>        <span class="hljs-comment">//(2) 迭代器</span><br>        System.out.println(<span class="hljs-string">&quot;---取出所有的value 迭代器----&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator2</span> <span class="hljs-operator">=</span> values.iterator();<br>        <span class="hljs-keyword">while</span> (iterator2.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span>  iterator2.next();<br>            System.out.println(value);<br><br>        &#125;<br><br>        <span class="hljs-comment">//第三组: 通过EntrySet 来获取 k-v</span><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">entrySet</span> <span class="hljs-operator">=</span> map.entrySet();<span class="hljs-comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br>        <span class="hljs-comment">//(1) 增强for</span><br>        System.out.println(<span class="hljs-string">&quot;----使用EntrySet 的 for增强(第3种)----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object entry : entrySet) &#123;<br>            <span class="hljs-comment">//将entry 转成 Map.Entry</span><br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>            System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>        &#125;<br>        <span class="hljs-comment">//(2) 迭代器</span><br>        System.out.println(<span class="hljs-string">&quot;----使用EntrySet 的 迭代器(第4种)----&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator3</span> <span class="hljs-operator">=</span> entrySet.iterator();<br>        <span class="hljs-keyword">while</span> (iterator3.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span>  iterator3.next();<br>            <span class="hljs-comment">//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br>            <span class="hljs-comment">//向下转型 Map.Entry</span><br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Map.Entry) entry;<br>            System.out.println(m.getKey() + <span class="hljs-string">&quot;-&quot;</span> + m.getValue());<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-HashMap小结"><a href="#3-HashMap小结" class="headerlink" title="3.HashMap小结"></a>3.HashMap小结</h2><p>1.Map接口的常用实现类：HashMap、Hashtable、Properties</p><p>2.HashMap是Map接口使用频率最高的实现类</p><p>3.HashMap是以key-val对的方式来存储数据（HashMap$Node类型）</p><p>4.key不能重复，但是值可以重复，允许使用null键和null值</p><p>5.如果添加相同的key,则会覆盖原来的key-val，等同于修改。（key不会替换，val会替换）</p><p>6.于HashSet一样，不能保证映射的顺序，因为底层是以hash表的方式来存储的。</p><p>（jdk8的hashMap底层 数组+链表+红黑树）</p><p>7.HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有synchronized</p>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA集合学习之Set篇</title>
    <link href="/2022/05/09/article_set/"/>
    <url>/2022/05/09/article_set/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合学习之Set篇"><a href="#JAVA集合学习之Set篇" class="headerlink" title="JAVA集合学习之Set篇"></a>JAVA集合学习之Set篇</h1><h2 id="1-set接口和常用方法"><a href="#1-set接口和常用方法" class="headerlink" title="1. set接口和常用方法"></a>1. set接口和常用方法</h2><h3 id="1-1-set接口基本介绍"><a href="#1-1-set接口基本介绍" class="headerlink" title="1.1 set接口基本介绍"></a>1.1 set接口基本介绍</h3><ol><li><p>无序（添加和取出的顺序不一致），没有索引，<strong>注意：取出的顺序虽然不是添加的顺序，但是它是固定的</strong>。</p></li><li><p>不允许重复元素，所以最多包含一个null</p></li><li><p>JDK API中Set接口的实现类有</p><p><img src="/2022/05/09/article_set/20210930095720.png" alt="image-20210930095712915"></p></li></ol><h3 id="1-2-set接口常用方法"><a href="#1-2-set接口常用方法" class="headerlink" title="1.2 set接口常用方法"></a>1.2 set接口常用方法</h3><p>和List接口一样，set接口也是Collection的子接口，因此，常用方法和Collection接口一样</p><h3 id="1-3set接口的遍历方式"><a href="#1-3set接口的遍历方式" class="headerlink" title="1.3set接口的遍历方式"></a>1.3set接口的遍历方式</h3><p>同Collection的遍历方法一样，因为set接口是Collection接口的子接口。</p><ol><li>可以使用迭代器</li><li>增强for</li><li>&#x3D;&#x3D;不能使用索引的方式遍历&#x3D;&#x3D;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        以set接口的实现子类 HashSet举例 set接口方法</span><br><span class="hljs-comment">//        1. set接口的实现类（Set接口对象），不能存放重复的元素，可以添加一个null</span><br><span class="hljs-comment">//        2. set接口对象存放的数据是无序的（即添加的顺序和取出的顺序不一致）</span><br><span class="hljs-comment">//        3. 注意：取出的顺序虽然不是添加的顺序，但是它是固定的。</span><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        set.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;2&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;4&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;100&quot;</span>);<br>        set.add(<span class="hljs-literal">null</span>);<br>        set.add(<span class="hljs-literal">null</span>);<br>        System.out.println(set);<br><span class="hljs-comment">//        遍历</span><br><span class="hljs-comment">//        1. 迭代器</span><br>        System.out.println(<span class="hljs-string">&quot;====迭代器遍历&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> set.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span>  iterator.next();<br>            System.out.println(next);<br>        &#125;<br><span class="hljs-comment">//         2. 增强for遍历</span><br>        System.out.println(<span class="hljs-string">&quot;====增强for遍历&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object o : set) &#123;<br>            System.out.println(o);<br>        &#125;<br><span class="hljs-comment">//        set接口对象，不能通过索引来获取，无法使用 普通for循环遍历</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/09/article_set/20210930101904.png" alt="image-20210930101904730"></p><h2 id="2-HashSet"><a href="#2-HashSet" class="headerlink" title="2.HashSet"></a>2.HashSet</h2><h3 id="2-1Hash基本介绍"><a href="#2-1Hash基本介绍" class="headerlink" title="2.1Hash基本介绍"></a>2.1Hash基本介绍</h3><ol><li><p>HashSet 实现了Set接口</p></li><li><p>HashSet 实际上是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment"> * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，取决于hash值，再确定索引的结果</p></li><li><p>不能有重复元素&#x2F;对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.set_;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br><br>        <span class="hljs-comment">//说明</span><br>        <span class="hljs-comment">//1. 在执行add方法后，会返回一个boolean值</span><br>        <span class="hljs-comment">//2. 如果添加成功，返回 true, 否则返回false</span><br>        <span class="hljs-comment">//3. 可以通过 remove 指定删除哪个对象</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;john&quot;</span>));<span class="hljs-comment">//T</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;lucy&quot;</span>));<span class="hljs-comment">//T</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;john&quot;</span>));<span class="hljs-comment">//F</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;jack&quot;</span>));<span class="hljs-comment">//T</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;Rose&quot;</span>));<span class="hljs-comment">//T</span><br><br><br>        set.remove(<span class="hljs-string">&quot;john&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;set=&quot;</span> + set);<span class="hljs-comment">//3个</span><br><br>        <span class="hljs-comment">//</span><br>        set  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        System.out.println(<span class="hljs-string">&quot;set=&quot;</span> + set);<span class="hljs-comment">//0</span><br>        <span class="hljs-comment">//4 Hashset 不能添加相同的元素/数据?</span><br>        set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//添加成功</span><br>        set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">//加入不了</span><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//OK</span><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//Ok</span><br>        System.out.println(<span class="hljs-string">&quot;set=&quot;</span> + set);<br><br>        <span class="hljs-comment">//在加深一下. 非常经典的面试题.</span><br>        <span class="hljs-comment">//看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然</span><br>        <span class="hljs-comment">//去看他的源码，即 add 到底发生了什么?=&gt; 底层机制.</span><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//ok</span><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hsp&quot;</span>));<span class="hljs-comment">//加入不了.</span><br>        System.out.println(<span class="hljs-string">&quot;set=&quot;</span> + set);<br><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123; <span class="hljs-comment">//定义了Dog类</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2022/05/09/article_set/image-20220510095453101.png" alt="image-20220510095453101"></p></li></ol><h3 id="2-2HashSet-底层机制"><a href="#2-2HashSet-底层机制" class="headerlink" title="2.2HashSet 底层机制"></a>2.2HashSet 底层机制</h3><p>HashSet 底层是HashMap，HashMap底层是（数组+链表+红黑树）</p><p><img src="/2022/05/09/article_set/image-20220510095751423.png" alt="image-20220510095751423"></p><h3 id="2-3模拟底层简单结构"><a href="#2-3模拟底层简单结构" class="headerlink" title="2.3模拟底层简单结构"></a>2.3模拟底层简单结构</h3><p>结构：</p><p><img src="/2022/05/09/article_set/20210930111257.png" alt="image-20210930111256972"></p><p><img src="/2022/05/09/article_set/image-20220510095546365.png" alt="image-20220510095546365"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetStructure</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-comment">//        模拟 HashSet 的底层 即HashMap底层</span><br><br><span class="hljs-comment">//        1. 创建一个数组，数组的类型是Node</span><br>        Node[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">16</span>];<br>        System.out.println(<span class="hljs-string">&quot;table=&quot;</span>+table);<br><br><span class="hljs-comment">//        2. 创建节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">john</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;john&quot;</span>,<span class="hljs-literal">null</span>);<br><br>        table[<span class="hljs-number">2</span>] = john;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">jack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//        将jack节点挂载到 john后</span><br>        john.next = jack;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">rose</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//        将rose节点挂载到jack后</span><br>        jack.next = rose;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">lucy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//        把lucy放到 table数组索引为3的位置</span><br>        table[<span class="hljs-number">3</span>] = lucy;<br><br>        System.out.println(<span class="hljs-string">&quot;table=&quot;</span>+table);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//节点，存储数据，可以指向下一个节点，从而形成链表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    Object item; <span class="hljs-comment">//存放数据</span><br>    Node next;   <span class="hljs-comment">// 指向下一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Object item, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.item = item;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/09/article_set/20210930111313.png" alt="image-20210930111313858"></p><h3 id="2-4HashSet-add-方法底层"><a href="#2-4HashSet-add-方法底层" class="headerlink" title="2.4HashSet add()方法底层"></a>2.4HashSet add()方法底层</h3><ol><li>HashSet 底层是 HashMap</li><li>添加一个元素时，先得到hash值 会转成 -&gt; 索引值</li><li>找到存储数据表table，看这个索引位置是否已经存放的有元素</li><li>如果没有，直接加入</li><li>如果有，调用 equals() 比较， 如果想同，就放弃添加，如果不相同，则添加到最后</li><li>在 java8 中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPCAITY（默认64），就会进行树化（红黑树）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetSource</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br><br>        hashSet.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;pp&quot;</span>);<br>        hashSet.add(<span class="hljs-string">&quot;java&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;haseSet=&quot;</span>+hashSet);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-1-底层源码分析"><a href="#2-4-1-底层源码分析" class="headerlink" title="2.4.1 底层源码分析"></a>2.4.1 底层源码分析</h4><ol><li><p>创建hashset对象，构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment"> * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds the specified element to this set if it is not already present.</span><br><span class="hljs-comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="hljs-comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="hljs-comment"> * If this set already contains the element, the call leaves the set</span><br><span class="hljs-comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="hljs-comment"> * element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;    <span class="hljs-comment">// e:&quot;java&quot;</span><br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;  <span class="hljs-comment">//e:&quot;java&quot; map:&quot;&#123;&#125;&quot;  (static) PRESENT =  new Object</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行put()方法，该方法会执行hash(key)方法，得到key对应的hash值（不是hashcode，通过算法计算hash值，降低hash冲突的几率）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Associates the specified value with the specified key in this map.</span><br><span class="hljs-comment"> * If the map previously contained a mapping for the key, the old</span><br><span class="hljs-comment"> * value is replaced.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="hljs-comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="hljs-comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="hljs-comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;   <span class="hljs-comment">// key:&quot;java&quot;  value:PRESENT/Object@502</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// key:&quot;java&quot;  value:PRESENT/Object@502</span><br>&#125;<br></code></pre></td></tr></table></figure><p>hash(key)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="hljs-comment"> * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="hljs-comment"> * hashes that vary only in bits above the current mask will</span><br><span class="hljs-comment"> * always collide. (Among known examples are sets of Float keys</span><br><span class="hljs-comment"> * holding consecutive whole numbers in small tables.)  So we</span><br><span class="hljs-comment"> * apply a transform that spreads the impact of higher bits</span><br><span class="hljs-comment"> * downward. There is a tradeoff between speed, utility, and</span><br><span class="hljs-comment"> * quality of bit-spreading. Because many common sets of hashes</span><br><span class="hljs-comment"> * are already reasonably distributed (so don&#x27;t benefit from</span><br><span class="hljs-comment"> * spreading), and because we use trees to handle large sets of</span><br><span class="hljs-comment"> * collisions in bins, we just XOR some shifted bits in the</span><br><span class="hljs-comment"> * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="hljs-comment"> * to incorporate impact of the highest bits that would otherwise</span><br><span class="hljs-comment"> * never be used in index calculations because of table bounds.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>); <span class="hljs-comment">// &gt;&gt;&gt; 无符号右移16位，降低hash冲突的几率</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&#x3D;&#x3D;<strong>putVal()方法</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Implements Map.put and related methods.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> hash         hash for key</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> key          the key</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value        the value to put</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> evict        if false, the table is in creation mode.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> previous value, or null if none</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                 <span class="hljs-type">boolean</span> evict)</span> &#123;<br>      Node&lt;K, V&gt;[] tab;<br>      Node&lt;K, V&gt; p;<br>      <span class="hljs-type">int</span> n, i; <span class="hljs-comment">//定义了辅助变量</span><br>      <span class="hljs-comment">//table 就是 HashMap 的一个数组，类型是 Node[]</span><br>      <span class="hljs-comment">//if 语句表示如果当前table 是null, 或者 大小=0</span><br>      <span class="hljs-comment">//就是第一次扩容，到16个空间.</span><br>      <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>          n = (tab = resize()).length;<br>   <br>      <span class="hljs-comment">//(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置</span><br>      <span class="hljs-comment">//并把这个位置的对象，赋给 p</span><br>      <span class="hljs-comment">//(2)判断p 是否为null</span><br>      <span class="hljs-comment">//(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key=&quot;java&quot;,value=PRESENT)</span><br>      <span class="hljs-comment">//(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span><br>   <br>      <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>          tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span><br>          Node&lt;K, V&gt; e;<br>          K k; <span class="hljs-comment">//</span><br>          <span class="hljs-comment">//如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span><br>          <span class="hljs-comment">//并且满足 下面两个条件之一:</span><br>          <span class="hljs-comment">//(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span><br>          <span class="hljs-comment">//(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同</span><br>          <span class="hljs-comment">//就不能加入</span><br>          <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                  ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>              e = p;<br>              <span class="hljs-comment">//再判断 p 是不是一颗红黑树,</span><br>              <span class="hljs-comment">//如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>              e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>          <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果table对应索引位置，已经是一个链表, 就使用for循环比较</span><br>              <span class="hljs-comment">//(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span><br>              <span class="hljs-comment">//    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点</span><br>              <span class="hljs-comment">//    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span><br>              <span class="hljs-comment">//    注意，在转成红黑树时，要进行判断, 判断条件</span><br>              <span class="hljs-comment">//    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span><br>              <span class="hljs-comment">//            resize();</span><br>              <span class="hljs-comment">//    如果上面条件成立，先table扩容.</span><br>              <span class="hljs-comment">//    只有上面条件不成立时，才进行转成红黑树</span><br>              <span class="hljs-comment">//(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span><br>   <br>              <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                  <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                      p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                      <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD(<span class="hljs-number">8</span>) - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                          treeifyBin(tab, hash);<br>                      <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                  <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                          ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                      <span class="hljs-keyword">break</span>;<br>                  p = e;<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>              <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>              <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                  e.value = value;<br>              afterNodeAccess(e);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<br>      ++modCount;<br>      <span class="hljs-comment">//size 就是我们每加入一个结点Node(k,v,h,next), size++</span><br>      <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>          resize();<span class="hljs-comment">//扩容</span><br>      afterNodeInsertion(evict);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-4-2-源码补充说明"><a href="#2-4-2-源码补充说明" class="headerlink" title="2.4.2 源码补充说明"></a>2.4.2 源码补充说明</h4><p><img src="/2022/05/09/article_set/image-20220604205916730.png" alt="image-20220604205916730"></p><p><img src="/2022/05/09/article_set/image-20220604210024004.png" alt="image-20220604210024004"></p><p>要实现当name和age的值相同时，就是同一个员工，重写hashCode方法和equals方法</p><h3 id="2-5-LinkedHashSet"><a href="#2-5-LinkedHashSet" class="headerlink" title="2.5 LinkedHashSet"></a>2.5 LinkedHashSet</h3><h4 id="2-5-1LinkedHashSet-的全面说明"><a href="#2-5-1LinkedHashSet-的全面说明" class="headerlink" title="2.5.1LinkedHashSet 的全面说明"></a>2.5.1LinkedHashSet 的全面说明</h4><ol><li><p>LinkedHashSet是HashSet的子类</p></li><li><p>LinkedHashSet底层是一个LinkedHashMap,底层维护一个 <strong>数组</strong>+<strong>双向链表</strong></p></li><li><p>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</p></li><li><p>LinkedHashSet不允许添加重复元素</p><p><img src="/2022/05/09/article_set/image-20220605160210088.png" alt="image-20220605160210088"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2022/05/06/article_jvm/"/>
    <url>/2022/05/06/article_jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><p><strong>定义</strong></p><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><p><strong>好处</strong></p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><p><strong>jdk、jre、jvm比较</strong></p><p><img src="/2022/05/06/article_jvm/20200608150422.png" alt="img"></p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><strong>整体架构</strong></p><p><img src="/2022/05/06/article_jvm/20200608150440.png" alt="img"></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码 </li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>method1();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/06/article_jvm/20200608150534.png" alt="img"></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><p><strong>问题辨析</strong></p><ul><li><p>垃圾回收是否涉及栈内存？</p><ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li><p>栈内存的分配越大越好吗？</p><ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li><p>方法内的局部变量是否是线程安全的？</p><ul><li><p>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</p></li><li><p>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p></li><li><div class="code-wrapper"><pre><code class="java">package cn.itcast.jvm.t1.stack;/** * 局部变量的线程安全问题 */public class Demo1_17 &#123;    public static void main(String[] args) &#123;        StringBuilder sb = new StringBuilder();        sb.append(4);        sb.append(5);        sb.append(6);        new Thread(()-&gt;&#123;            m2(sb);        &#125;).start();    &#125;    public static void m1() &#123;        StringBuilder sb = new StringBuilder();        sb.append(1);        sb.append(2);        sb.append(3);        System.out.println(sb.toString());    &#125;    public static void m2(StringBuilder sb) &#123;        sb.append(1);        sb.append(2);        sb.append(3);        System.out.println(sb.toString());    &#125;    public static StringBuilder m3() &#123;        StringBuilder sb = new StringBuilder();        sb.append(1);        sb.append(2);        sb.append(3);        return sb;    &#125;&#125;</code></pre></div></li></ul></li></ul><p><strong>内存溢出</strong></p><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈（线程私有）"><a href="#3、本地方法栈（线程私有）" class="headerlink" title="3、本地方法栈（线程私有）"></a>3、本地方法栈（线程私有）</h3><p>java虚拟机调用<strong>本地方法</strong>时需要给本地方法提供一些内存空间，<strong>本地方法栈</strong>就是这些内存空间（本地方法指不是由java代码编写的方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到用C或C++编写的本地方法）</p><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA集合学习之List篇</title>
    <link href="/2022/05/06/article_list/"/>
    <url>/2022/05/06/article_list/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合学习之List篇"><a href="#JAVA集合学习之List篇" class="headerlink" title="JAVA集合学习之List篇"></a>JAVA集合学习之List篇</h1><h2 id="1-集合的好处和理解"><a href="#1-集合的好处和理解" class="headerlink" title="1.集合的好处和理解"></a>1.集合的好处和理解</h2><h3 id="1-1数组"><a href="#1-1数组" class="headerlink" title="1.1数组"></a>1.1数组</h3><p>1.长度开始必须指定，而且一旦修改，不能更改</p><p>2.保存的必须是同一个类型的元素</p><p>3.使用数组进行增加、删除元素比较，麻烦</p><h3 id="1-2集合"><a href="#1-2集合" class="headerlink" title="1.2集合"></a>1.2集合</h3><p>1.可以<strong>动态保存</strong>任意多个对象，使用比较方便</p><p>2.提供一系列方便的操作对象的方法：add、remove、set、get等等</p><h2 id="2-集合的框架体系-背"><a href="#2-集合的框架体系-背" class="headerlink" title="2.集合的框架体系(背)"></a>2.集合的框架体系(背)</h2><p><img src="/2022/05/06/article_list/image-20220506091006461.png" alt="image-20220506091006461"></p><p><img src="/2022/05/06/article_list/image-20220506091019328.png" alt="image-20220506091019328"></p><h2 id="3-Collection接口和常用方法"><a href="#3-Collection接口和常用方法" class="headerlink" title="3.Collection接口和常用方法"></a>3.Collection接口和常用方法</h2><h3 id="3-1Collection接口实现类的特点"><a href="#3-1Collection接口实现类的特点" class="headerlink" title="3.1Collection接口实现类的特点"></a>3.1Collection接口实现类的特点</h3><p>1.实现这个接口的子类，可以存放多个元素，每个元素可以是Object</p><p>2.有些实现这个接口的子类，有些是有序（List）,有些是无序（Set）</p><p>3.有些实现这个接口的子类,有些可以存放重复元素，有些不行</p><p>4.Collection接口没有直接的实现子类，通过子接口List和Set来实现</p><h3 id="3-2Collection接口的常用方法"><a href="#3-2Collection接口的常用方法" class="headerlink" title="3.2Collection接口的常用方法"></a>3.2Collection接口的常用方法</h3><p>add()、remove()、contains()、isEmpty()、clear()、addAll()、removeAll()</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.collection_;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionMethod</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//        add:添加单个元素</span><br>        list.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">//list.add(new Integer(10))</span><br>        list.add(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        remove:删除指定元素</span><br>        <span class="hljs-comment">//list.remove(0);//删除第一个元素</span><br>        list.remove(<span class="hljs-literal">true</span>);<span class="hljs-comment">//指定删除某个元素</span><br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        contains:查找元素是否存在</span><br>        System.out.println(list.contains(<span class="hljs-string">&quot;jack&quot;</span>));<span class="hljs-comment">//T</span><br><span class="hljs-comment">//        size:获取元素个数</span><br>        System.out.println(list.size());<span class="hljs-comment">//2</span><br><span class="hljs-comment">//        isEmpty:判断是否为空</span><br>        System.out.println(list.isEmpty());<span class="hljs-comment">//F</span><br><span class="hljs-comment">//        clear:清空</span><br>        list.clear();<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        addAll:添加多个元素</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list2.add(<span class="hljs-string">&quot;红楼梦&quot;</span>);<br>        list2.add(<span class="hljs-string">&quot;三国演义&quot;</span>);<br>        list.addAll(list2);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        containsAll:查找多个元素是否都存在</span><br>        System.out.println(list.containsAll(list2));<span class="hljs-comment">//T</span><br><span class="hljs-comment">//        removeAll：删除多个元素</span><br>        list.add(<span class="hljs-string">&quot;聊斋&quot;</span>);<br>        list.removeAll(list2);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<span class="hljs-comment">//[聊斋]</span><br><span class="hljs-comment">//        说明：以ArrayList实现类来演示.</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3Collection接口遍历元素方式"><a href="#3-3Collection接口遍历元素方式" class="headerlink" title="3.3Collection接口遍历元素方式"></a>3.3Collection接口遍历元素方式</h3><p><strong>方式1 (使用Iterator迭代器)</strong></p><p>1.Iterator称为迭代器，主要用于遍历Collection集合的元素</p><p>2.所有实现Collection接口的子类都有一个Iterator()方法,该方法返回一个实现Iterator接口的对象，即可以返回一个迭代器</p><p>3.执行原理<img src="/2022/05/06/article_list/image-20220506094316028.png" alt="image-20220506094316028"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.collection_;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionIterator</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-string">&quot;罗贯中&quot;</span>, <span class="hljs-number">10.1</span>));<br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;小李飞刀&quot;</span>, <span class="hljs-string">&quot;古龙&quot;</span>, <span class="hljs-number">5.1</span>));<br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;红楼梦&quot;</span>, <span class="hljs-string">&quot;曹雪芹&quot;</span>, <span class="hljs-number">34.6</span>));<br><br><br>        <span class="hljs-comment">//System.out.println(&quot;col=&quot; + col);</span><br>        <span class="hljs-comment">//现在老师希望能够遍历 col集合</span><br>        <span class="hljs-comment">//1. 先得到 col 对应的 迭代器</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> col.iterator();<br>        <span class="hljs-comment">//2. 使用while循环遍历</span><br><span class="hljs-comment">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span><br><span class="hljs-comment">//            //返回下一个元素，类型是Object</span><br><span class="hljs-comment">//            Object obj = iterator.next();</span><br><span class="hljs-comment">//            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//老师教大家一个快捷键，快速生成 while =&gt; itit</span><br>        <span class="hljs-comment">//显示所有的快捷键的的快捷键 ctrl + j</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.println(<span class="hljs-string">&quot;obj=&quot;</span> + obj);<br><br>        &#125;<br>        <span class="hljs-comment">//3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br>        <span class="hljs-comment">//   iterator.next();//NoSuchElementException</span><br>        <span class="hljs-comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span><br>        iterator = col.iterator();<br>        System.out.println(<span class="hljs-string">&quot;===第二次遍历===&quot;</span>);<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.println(<span class="hljs-string">&quot;obj=&quot;</span> + obj);<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String author;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name, String author, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.author = author;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthor</span><span class="hljs-params">(String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>方式2（增强for循环）</strong></p><p>就是简化版的迭代器，底层和迭代器一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.collection_;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionFor</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-string">&quot;罗贯中&quot;</span>, <span class="hljs-number">10.1</span>));<br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;小李飞刀&quot;</span>, <span class="hljs-string">&quot;古龙&quot;</span>, <span class="hljs-number">5.1</span>));<br>        col.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;红楼梦&quot;</span>, <span class="hljs-string">&quot;曹雪芹&quot;</span>, <span class="hljs-number">34.6</span>));<br><br>        <span class="hljs-comment">//老韩解读</span><br>        <span class="hljs-comment">//1. 使用增强for, 在Collection集合</span><br>        <span class="hljs-comment">//2. 增强for， 底层仍然是迭代器</span><br>        <span class="hljs-comment">//3. 增强for可以理解成就是简化版本的 迭代器遍历</span><br>        <span class="hljs-comment">//4. 快捷键方式 I</span><br><span class="hljs-comment">//        for (Object book : col) &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;book=&quot; + book);</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-keyword">for</span> (Object o : col) &#123;<br>            System.out.println(<span class="hljs-string">&quot;book=&quot;</span> + o);<br>        &#125;<br><br>        <span class="hljs-comment">//增强for，也可以直接在数组使用</span><br><span class="hljs-comment">//        int[] nums = &#123;1, 8, 10, 90&#125;;</span><br><span class="hljs-comment">//        for (int i : nums) &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;i=&quot; + i);</span><br><span class="hljs-comment">//        &#125;</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-List-接口和常用方法"><a href="#4-List-接口和常用方法" class="headerlink" title="4.List 接口和常用方法"></a>4.List 接口和常用方法</h2><h3 id="4-1-List-接口基本介绍"><a href="#4-1-List-接口基本介绍" class="headerlink" title="4.1 List 接口基本介绍"></a>4.1 List 接口基本介绍</h3><p>List接口是Collection接口的子接口</p><p>1.List集合中元素有序，（添加和取出的顺序一致）、且元素可重复</p><p>2.List集合中每个元素都支持索引，可以通过下标取得元素，例如list.get(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.list_;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List_</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1. List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复 [案例]</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;mary&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;hsp&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br>        <span class="hljs-comment">//2. List集合中的每个元素都有其对应的顺序索引，即支持索引</span><br>        <span class="hljs-comment">//   索引是从0开始的</span><br>        System.out.println(list.get(<span class="hljs-number">3</span>));<span class="hljs-comment">//hsp</span><br>        <span class="hljs-comment">//3.</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-2-List接口的常用方法"><a href="#4-2-List接口的常用方法" class="headerlink" title="4.2 List接口的常用方法"></a>4.2 List接口的常用方法</h3><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>void add ( int index , Object ele)</strong></td><td align="left"><strong>在index位置插入ele元素</strong></td></tr><tr><td align="left"><strong>boolean addAll ( int index , Collection eles)</strong></td><td align="left"><strong>从index位置开始将eles中的所有元素添加进来</strong></td></tr><tr><td align="left"><strong>Object get ( int index )</strong></td><td align="left"><strong>获取指定index位置的元素</strong></td></tr><tr><td align="left"><strong>int indexOf ( Object obj)</strong></td><td align="left"><strong>返回obj在集合中首次出现的位置</strong></td></tr><tr><td align="left"><strong>int lastIndexOf ( Object obj)</strong></td><td align="left"><strong>返回obj在当前集合中末次出现的位置</strong></td></tr><tr><td align="left"><strong>Object remove ( int index)</strong></td><td align="left"><strong>移除指定index位置的元素，并返回此元素</strong></td></tr><tr><td align="left"><strong>Object set ( int index , Object ele)</strong></td><td align="left"><strong>设置指定index位置的元素为ele，相当于是替换</strong></td></tr><tr><td align="left"><strong>List subList ( int fromeIndex , int toIndex)</strong></td><td align="left"><strong>返回从fromIndex 到 toIndex 位置的子集合（左闭右开）</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.list_;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListMethod</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;贾宝玉&quot;</span>);<br><span class="hljs-comment">//        void add(int index, Object ele):在index位置插入ele元素</span><br>        <span class="hljs-comment">//在index = 1的位置插入一个对象</span><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;韩顺平&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list2.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        list2.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        list.addAll(<span class="hljs-number">1</span>, list2);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        Object get(int index):获取指定index位置的元素</span><br>        <span class="hljs-comment">//说过</span><br><span class="hljs-comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br>        System.out.println(list.indexOf(<span class="hljs-string">&quot;tom&quot;</span>));<span class="hljs-comment">//2</span><br><span class="hljs-comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br>        list.add(<span class="hljs-string">&quot;韩顺平&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br>        System.out.println(list.lastIndexOf(<span class="hljs-string">&quot;韩顺平&quot;</span>));<br><span class="hljs-comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span><br>        list.remove(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;玛丽&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br>        <span class="hljs-comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">returnlist</span> <span class="hljs-operator">=</span> list.subList(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;returnlist=&quot;</span> + returnlist);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-3List的三种遍历方式"><a href="#4-3List的三种遍历方式" class="headerlink" title="4.3List的三种遍历方式"></a>4.3List的三种遍历方式</h3><p><img src="/2022/05/06/article_list/image-20220507084146773.png" alt="image-20220507084146773"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.list_;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListFor</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//List 接口的实现子类 Vector LinkedList</span><br>        <span class="hljs-comment">//List list = new ArrayList();</span><br>        <span class="hljs-comment">//List list = new Vector();</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><br>        list.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;tom&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;鱼香肉丝&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;北京烤鸭子&quot;</span>);<br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//1. 迭代器</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span>  iterator.next();<br>            System.out.println(obj);<br><br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=====增强for=====&quot;</span>);<br>        <span class="hljs-comment">//2. 增强for</span><br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            System.out.println(<span class="hljs-string">&quot;o=&quot;</span> + o);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=====普通for====&quot;</span>);<br>        <span class="hljs-comment">//3. 使用普通for</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;对象=&quot;</span> + list.get(i));<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-4-ArrayList-底层结构和源码分析"><a href="#4-4-ArrayList-底层结构和源码分析" class="headerlink" title="4.4 ArrayList 底层结构和源码分析"></a>4.4 ArrayList 底层结构和源码分析</h3><p><strong>1</strong>.<strong>ArrayList 注意事项</strong></p><ol><li>ArrayList 可以加入null，并且多个</li><li>ArrayList是由数组来实现的</li><li>ArrayList基本等同于Vector，除了 ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrrayList。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//ArrayList 是线程不安全，源码 没有 synchronized</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>       ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>       elementData[size++] = e;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>2.ArrayList 的底层操作机制源码分析（重点，难点）</strong></p><ol><li>ArrayList 中维护了一个 Object类型的数组 elementData。<br>transient Object[] elementData; &#x2F;&#x2F; <strong>transient 标识瞬间，短暂的，表示该属性不会被序列化</strong></li><li>当创建ArrayList对象时，<strong>如果使用的是无参构造器</strong>，则初始elementData 容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍。</li><li><strong>如果使用的是指定大小的构造器</strong>，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</li></ol><p><strong>源程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.list_;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListSource</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//老韩解读源码</span><br>        <span class="hljs-comment">//注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据</span><br>        <span class="hljs-comment">//需要做设置.</span><br>        <span class="hljs-comment">//使用无参构造器创建ArrayList对象</span><br><span class="hljs-comment">//        ArrayList list = new ArrayList();</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-number">8</span>);<br>        <span class="hljs-comment">//使用for给list集合添加 1-10数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">//使用for给list集合添加 11-15数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        list.add(<span class="hljs-number">100</span>);<br>        list.add(<span class="hljs-number">200</span>);<br>        list.add(<span class="hljs-literal">null</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>在<code>ArrayList list = new ArrayList();</code> 处添加断点</p></li><li><p>debug – step Into 到 ArrayList.java的ArrarList()构造方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br></code></pre></td></tr></table></figure><p>查询<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>可发现 默认为空数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Shared empty array instance used for default sized empty instances. We</span><br><span class="hljs-comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="hljs-comment">     * first element is added.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li>第一次for循环，程序先进入<code>Integer valueOf()</code> 方法对数据进行装箱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后执行 list 的<code>boolean add(E e)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>boolean add(E e)</code>方法中，先执行<code>ensureCapacityInternal(size + 1)</code>方法确定是否要扩容，然后再执行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>calculateCapacity()</code>方法中 先确定elementData是否为空数组，如果为空数组，返回DEFAULT_CAPACITY(默认为10) 和 minCapacity(第一次为1) 中的最大值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapacity;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>ensureExplicitCapacity(int minCapacity)</code>方法中确定是否真的扩容</p><p>modCount++ ：记录集合修改次数</p><p>minCapacity - elementData.length &gt; 0 ：如果数组所需最小容量 - 数组当前实际大小 大于 0 则执行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            grow(minCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>grow()</code>方法执行扩容</p><ol><li>将elementData.length 记录到 oldCapacity中，第一次值为0</li><li>newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); 执行扩容，扩容大小为 数组当前容量+数组当前大小右移1位(除以2)，即扩容1.5倍</li><li>因为第一次扩容oldCapacity 为0 所有newCapacity 也为0，执行<br><code>if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;</code><br>此时newCapacity 为 10，所以第一次扩容大小为 10</li><li><code>elementData = Arrays.copyOf(elementData, newCapacity);</code><br>Arrays.copyOf()方法可保留原先数据扩容<br>执行Arrays.copyOf()方法进行扩容，第一次执行完elementData 中有10个空数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Increases the capacity to ensure that it can hold at least the</span><br><span class="hljs-comment">     * number of elements specified by the minimum capacity argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> minCapacity the desired minimum capacity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>扩容完成后，继续执行add()方法，将数据添加到elementData数组中</p><p>流程图如下：</p><p><img src="/2022/05/06/article_list/image-20220507110407823.png" alt="image-20220507110407823"></p><p><img src="/2022/05/06/article_list/image-20220507110428514.png" alt="image-20220507110428514"></p><h3 id="4-5Vector的基本介绍和源码分析"><a href="#4-5Vector的基本介绍和源码分析" class="headerlink" title="4.5Vector的基本介绍和源码分析"></a>4.5Vector的基本介绍和源码分析</h3><h4 id="4-5-1基本介绍"><a href="#4-5-1基本介绍" class="headerlink" title="4.5.1基本介绍"></a>4.5.1<strong>基本介绍</strong></h4><p>1.Vector的定义</p><p><img src="/2022/05/06/article_list/image-20220508102254240.png" alt="image-20220508102254240"></p><p>2.Vector 底层也是一个对象数组，<code>protected Object[] elementData;</code></p><p>3.Vector 是线程同步的，即线程安全，Vector 类的操作方法带有 &#x3D;&#x3D;<strong>synchronized</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.在开发中，需要线程同步安全时，考虑使用Vector.</p><p>5.Vector和ArrayList的比较</p><table><thead><tr><th align="left"></th><th align="left">底层结构</th><th align="left">版本</th><th align="left">线程安全（同步）效率</th><th align="left">扩容倍数</th></tr></thead><tbody><tr><td align="left">ArrayList</td><td align="left">可变数组</td><td align="left">jdk1.2</td><td align="left">不安全，效率高</td><td align="left">如果有参构造1.5倍，如果是无参 ，默认初始化容量是0，第一次扩容为10，然后以后扩容按1.5倍扩</td></tr><tr><td align="left">Vector</td><td align="left">可变数组</td><td align="left">jdk1.0</td><td align="left">安全，效率不高</td><td align="left">如果是无参，默认初始化容量10，满后，就按2倍扩容。如果指定大小，则每次直接按2倍扩容</td></tr></tbody></table><h4 id="4-5-2-Vector源码分析"><a href="#4-5-2-Vector源码分析" class="headerlink" title="4.5.2 Vector源码分析"></a>4.5.2 Vector源码分析</h4><p>创建Vector对象，并循环添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector_</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        无参构造 创建对象</span><br>        <span class="hljs-type">Vector</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            vector.add(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>创建Vector 对象，首先执行无参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>所以 new Vector() 会默认创建 容量为10的 对象</p><p><img src="/2022/05/06/article_list/20210929092119.png" alt="image-20210929092112608">](</p></li><li><p>add 方法添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>     modCount++;<br>     ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>     elementData[elementCount++] = e;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>首先执行ensureCapacityHelper() 方法判断是否要扩容。</p><p>如果数组所需最小容量大于当前数组容量，执行grow()方法扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>grow()方法源码：</p><p>默认扩容两倍大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                         capacityIncrement : oldCapacity);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>也可指定扩容大小。在vector带参构造器中指定扩容大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-6LinkedList底层结构"><a href="#4-6LinkedList底层结构" class="headerlink" title="4.6LinkedList底层结构"></a>4.6LinkedList底层结构</h3><h4 id="4-6-1-LinkedList-基本介绍"><a href="#4-6-1-LinkedList-基本介绍" class="headerlink" title="4.6.1 LinkedList 基本介绍"></a>4.6.1 LinkedList 基本介绍</h4><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素（元素可以重复），包括null</li><li>线程不安全，没有实现同步</li></ol><h4 id="4-6-2-LinkedList-的底层操作机制"><a href="#4-6-2-LinkedList-的底层操作机制" class="headerlink" title="4.6.2 LinkedList 的底层操作机制"></a>4.6.2 LinkedList 的底层操作机制</h4><ol><li><p>LinkedList 底层维护了一个双向链表</p></li><li><p>LinkedList中维护了两个属性 first 和 last 分别指向 首节点和尾节点</p></li><li><p>每个节点（Node对象），里面又维护了prev、next、item、三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表。</p></li><li><p>LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</p><p><img src="/2022/05/06/article_list/20210929101626.png" alt="image-20210929101626433"></p></li></ol><h4 id="4-6-3-LinkedList-源码分析"><a href="#4-6-3-LinkedList-源码分析" class="headerlink" title="4.6.3 LinkedList 源码分析"></a>4.6.3 LinkedList 源码分析</h4><ul><li><p>LinkedList的增删改查案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListCRUD</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        linkedList.add(<span class="hljs-number">1</span>);<br>        linkedList.add(<span class="hljs-number">2</span>);<br>        linkedList.add(<span class="hljs-number">3</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;linkedList=&quot;</span>+linkedList);<br><br><span class="hljs-comment">//        删除节点,默认删除首节点</span><br>        linkedList.remove();<br>        System.out.println(<span class="hljs-string">&quot;linkedList=&quot;</span>+linkedList);<br><br><span class="hljs-comment">//        修改某个节点对象</span><br>        linkedList.set(<span class="hljs-number">0</span>,<span class="hljs-number">666</span>);<br>        System.out.println(<span class="hljs-string">&quot;linklist=&quot;</span>+linkedList);<br><br><span class="hljs-comment">//        得到某个节点对象</span><br><span class="hljs-comment">//        get(1)为第二个对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> linkedList.get(<span class="hljs-number">1</span>);<br>        System.out.println(o);<br><br><br><span class="hljs-comment">//        LinkedList 实现 List 接口 遍历可是迭代器</span><br>        System.out.println(<span class="hljs-string">&quot;====linkedList迭代器遍历&quot;</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> linkedList.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span>  iterator.next();<br>            System.out.println(next);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====增强for循环遍历&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object o1 : linkedList) &#123;<br>            System.out.println(o1);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====传统for循环&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; linkedList.size(); i++) &#123;<br>            System.out.println(linkedList.get(i));<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-6-4-LinkedList-添加元素"><a href="#4-6-4-LinkedList-添加元素" class="headerlink" title="4.6.4 LinkedList 添加元素"></a>4.6.4 LinkedList 添加元素</h4><ol><li><p>创建集合对象 <code>LinkedList linkedList = new LinkedList();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化双向链表</p><p><img src="/2022/05/06/article_list/20210929104849.png" alt="image-20210929104848943"></p></li></ol><ul><li><p>执行add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将新的节点，加入到双向链表的最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;<br>        size++;<br>        modCount++;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-6-5-LinkedList-删除元素"><a href="#4-6-5-LinkedList-删除元素" class="headerlink" title="4.6.5 LinkedList 删除元素"></a>4.6.5 LinkedList 删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//        删除节点,默认删除首节点</span><br>        linkedList.remove();<br>        System.out.println(<span class="hljs-string">&quot;linkedList=&quot;</span>+linkedList);<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> removeFirst();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先让 f 指向 首节点，判断首节点是否为空；</p><p>如果为空，抛出异常；</p><p>如果不为空，执行删除操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>       <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>       <span class="hljs-keyword">return</span> unlinkFirst(f);<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>执行删除操作</p><p>将 首节点置空，first指向下一个节点，下一个节点的prev指向空，即将下一个节点调整为首节点，原首节点有GC算法回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;<br>        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>        f.item = <span class="hljs-literal">null</span>;<br>        f.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>        first = next;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>            last = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            next.prev = <span class="hljs-literal">null</span>;<br>        size--;<br>        modCount++;<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-6-6-ArrayList-和-LinkedList-比较"><a href="#4-6-6-ArrayList-和-LinkedList-比较" class="headerlink" title="4.6.6 ArrayList 和 LinkedList 比较"></a>4.6.6 ArrayList 和 LinkedList 比较</h4><table><thead><tr><th align="left"></th><th align="left">底层结构</th><th align="left">增删效率</th><th align="left">改查效率</th></tr></thead><tbody><tr><td align="left">ArrayList</td><td align="left">可变数组</td><td align="left">较低，数组扩容</td><td align="left">较高</td></tr><tr><td align="left">LinkedList</td><td align="left">双向链表</td><td align="left">较高，通过链表追加</td><td align="left">较低</td></tr></tbody></table><p>如何选择ArrayList和LinkedList:</p><ol><li>如果改查的操作较多，选择ArrayList</li><li>如果增删的操作较多，选择LinkedList</li><li>一般来说，程序中，80%-90%都是查询，因此大部分情况下选择ArrayList</li><li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList。根据业务合理选择。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/03/hello-world/"/>
    <url>/2022/05/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>hello</p><p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" alt="test"></p><p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image-20220504234009772.png" alt="image-20220504234009772"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
